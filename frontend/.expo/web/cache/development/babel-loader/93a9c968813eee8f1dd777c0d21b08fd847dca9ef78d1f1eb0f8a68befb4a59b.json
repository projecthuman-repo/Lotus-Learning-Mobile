{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { lessThan, multiply, sub, add, divide, greaterThan, lessOrEq, eq } from \"../operators\";\nimport invariant from 'fbjs/lib/invariant';\nimport AnimatedNode from \"../core/AnimatedNode\";\nimport { createAnimatedCond as cond } from \"../core/AnimatedCond\";\nimport { createAnimatedFunction as proc } from \"../core/AnimatedFunction\";\nvar interpolateInternalSingleProc = proc(function (value, inS, inE, outS, outE) {\n  var progress = divide(sub(value, inS), sub(inE, inS));\n  var resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  var result = cond(eq(inS, inE), cond(lessOrEq(value, inS), outS, outE), resultForNonZeroRange);\n  return result;\n});\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  var inS = inputRange[offset];\n  var inE = inputRange[offset + 1];\n  var outS = outputRange[offset];\n  var outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\nfunction interpolateInternal(value, inputRange, outputRange) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n  return cond(lessThan(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));\n}\nexport var Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity'\n};\nfunction checkNonDecreasing(name, arr) {\n  for (var i = 1; i < arr.length; ++i) {\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode) continue;\n    invariant(arr[i] >= arr[i - 1], '%s must be monotonically non-decreasing. (%s)', name, arr);\n  }\n}\nfunction checkMinElements(name, arr) {\n  invariant(arr.length >= 2, '%s must have at least 2 elements. (%s)', name, arr);\n}\nfunction checkValidNumbers(name, arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(Number.isFinite(arr[i]), '%s cannot include %s. (%s)', name, arr[i], arr);\n  }\n}\nfunction convertToRadians(outputRange) {\n  for (var _ref of outputRange.entries()) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var i = _ref2[0];\n    var value = _ref2[1];\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\nexport default function interpolate(value, config) {\n  var inputRange = config.inputRange,\n    outputRange = config.outputRange,\n    _config$extrapolate = config.extrapolate,\n    extrapolate = _config$extrapolate === void 0 ? Extrapolate.EXTEND : _config$extrapolate,\n    extrapolateLeft = config.extrapolateLeft,\n    extrapolateRight = config.extrapolateRight;\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(inputRange.length === outputRange.length, 'inputRange and outputRange must be the same length.');\n  convertToRadians(outputRange);\n  var left = extrapolateLeft || extrapolate;\n  var right = extrapolateRight || extrapolate;\n  var output = interpolateInternal(value, inputRange, outputRange);\n  if (left === Extrapolate.EXTEND) {} else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n  if (right === Extrapolate.EXTEND) {} else if (right === Extrapolate.CLAMP) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), value, output);\n  }\n  return output;\n}","map":{"version":3,"names":["lessThan","multiply","sub","add","divide","greaterThan","lessOrEq","eq","invariant","AnimatedNode","createAnimatedCond","cond","createAnimatedFunction","proc","interpolateInternalSingleProc","value","inS","inE","outS","outE","progress","resultForNonZeroRange","result","interpolateInternalSingle","inputRange","outputRange","offset","interpolateInternal","arguments","length","undefined","Extrapolate","EXTEND","CLAMP","IDENTITY","checkNonDecreasing","name","arr","i","checkMinElements","checkValidNumbers","Number","isFinite","convertToRadians","_ref","entries","_ref2","_slicedToArray","endsWith","parseFloat","Math","PI","interpolate","config","_config$extrapolate","extrapolate","extrapolateLeft","extrapolateRight","left","right","output"],"sources":["/Users/negatwo/Documents/GitHub/BLN-App/frontend/node_modules/react-native-reanimated/lib/module/derived/interpolate.js"],"sourcesContent":["import {\n  lessThan,\n  multiply,\n  sub,\n  add,\n  divide,\n  greaterThan,\n  lessOrEq,\n  eq,\n} from '../operators';\nimport invariant from 'fbjs/lib/invariant';\n\nimport AnimatedNode from '../core/AnimatedNode';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\nimport { createAnimatedFunction as proc } from '../core/AnimatedFunction';\n\nconst interpolateInternalSingleProc = proc(function(\n  value,\n  inS,\n  inE,\n  outS,\n  outE\n) {\n  const progress = divide(sub(value, inS), sub(inE, inS));\n  // logic below was made in order to provide a compatibility witn an Animated API\n  const resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  const result = cond(\n    eq(inS, inE),\n    cond(lessOrEq(value, inS), outS, outE),\n    resultForNonZeroRange\n  );\n  return result;\n});\n\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  const inS = inputRange[offset];\n  const inE = inputRange[offset + 1];\n  const outS = outputRange[offset];\n  const outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\n\nfunction interpolateInternal(value, inputRange, outputRange, offset = 0) {\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n  return cond(\n    lessThan(value, inputRange[offset + 1]),\n    interpolateInternalSingle(value, inputRange, outputRange, offset),\n    interpolateInternal(value, inputRange, outputRange, offset + 1)\n  );\n}\n\nexport const Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity',\n};\n\nfunction checkNonDecreasing(name, arr) {\n  for (let i = 1; i < arr.length; ++i) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode)\n      continue;\n    invariant(\n      arr[i] >= arr[i - 1],\n      '%s must be monotonically non-decreasing. (%s)',\n      name,\n      arr\n    );\n  }\n}\n\nfunction checkMinElements(name, arr) {\n  invariant(\n    arr.length >= 2,\n    '%s must have at least 2 elements. (%s)',\n    name,\n    arr\n  );\n}\n\nfunction checkValidNumbers(name, arr) {\n  for (let i = 0; i < arr.length; i++) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(\n      Number.isFinite(arr[i]),\n      '%s cannot include %s. (%s)',\n      name,\n      arr[i],\n      arr\n    );\n  }\n}\n\nfunction convertToRadians(outputRange) {\n  for (const [i, value] of outputRange.entries()) {\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\n\nexport default function interpolate(value, config) {\n  const {\n    inputRange,\n    outputRange,\n    extrapolate = Extrapolate.EXTEND,\n    extrapolateLeft,\n    extrapolateRight,\n  } = config;\n\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(\n    inputRange.length === outputRange.length,\n    'inputRange and outputRange must be the same length.'\n  );\n\n  convertToRadians(outputRange);\n  const left = extrapolateLeft || extrapolate;\n  const right = extrapolateRight || extrapolate;\n  let output = interpolateInternal(value, inputRange, outputRange);\n\n  if (left === Extrapolate.EXTEND) {\n  } else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n\n  if (right === Extrapolate.EXTEND) {\n  } else if (right === Extrapolate.CLAMP) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      outputRange[outputRange.length - 1],\n      output\n    );\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      value,\n      output\n    );\n  }\n\n  return output;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}